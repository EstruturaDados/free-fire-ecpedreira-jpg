#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_COMPONENTES 20
#define TAM_NOME 30
#define TAM_TIPO 20

// =======================
// Struct do componente
// =======================
typedef struct {
    char nome[TAM_NOME];
    char tipo[TAM_TIPO];
    int prioridade; // 1 a 10
} Componente;

// =======================
// Fun√ß√µes utilit√°rias
// =======================

// Remove '\n' final vindo de fgets, se existir
void trim_newline(char *s) {
    size_t len = strlen(s);
    if (len == 0) return;
    if (s[len - 1] == '\n') s[len - 1] = '\0';
}

// Mostra o vetor de componentes formatado
void mostrarComponentes(Componente vet[], int n) {
    printf("\n---- Lista de Componentes (%d) ----\n", n);
    if (n == 0) {
        printf("Nenhum componente cadastrado.\n");
        return;
    }
    for (int i = 0; i < n; i++) {
        printf("%2d) Nome: %-28s | Tipo: %-12s | Prioridade: %d\n",
               i + 1, vet[i].nome, vet[i].tipo, vet[i].prioridade);
    }
    printf("-----------------------------------\n");
}

// =======================
// Ordena√ß√µes e contadores
// Cada fun√ß√£o recebe um ponteiro para contador de compara√ß√µes
// e retorna o tempo gasto em segundos.
// =======================

// 1) Bubble sort por nome (strings)
double bubbleSortNome(Componente vet[], int n, long *comparacoes) {
    *comparacoes = 0;
    clock_t ini = clock();

    for (int i = 0; i < n - 1; i++) {
        int trocou = 0;
        for (int j = 0; j < n - 1 - i; j++) {
            (*comparacoes)++;
            if (strcmp(vet[j].nome, vet[j+1].nome) > 0) {
                Componente tmp = vet[j];
                vet[j] = vet[j+1];
                vet[j+1] = tmp;
                trocou = 1;
            }
        }
        if (!trocou) break; // otimiza√ß√£o cl√°ssica do bubble
    }

    clock_t fim = clock();
    return (double)(fim - ini) / CLOCKS_PER_SEC;
}

// 2) Insertion sort por tipo (strings)
double insertionSortTipo(Componente vet[], int n, long *comparacoes) {
    *comparacoes = 0;
    clock_t ini = clock();

    for (int i = 1; i < n; i++) {
        Componente chave = vet[i];
        int j = i - 1;
        // comparar tipos
        while (j >= 0) {
            (*comparacoes)++;
            if (strcmp(vet[j].tipo, chave.tipo) > 0) {
                vet[j + 1] = vet[j];
                j--;
            } else {
                break;
            }
        }
        vet[j + 1] = chave;
    }

    clock_t fim = clock();
    return (double)(fim - ini) / CLOCKS_PER_SEC;
}

// 3) Selection sort por prioridade (inteiro) - ordena do maior para o menor? aqui iremos do menor para o maior
double selectionSortPrioridade(Componente vet[], int n, long *comparacoes) {
    *comparacoes = 0;
    clock_t ini = clock();

    for (int i = 0; i < n - 1; i++) {
        int idxMin = i;
        for (int j = i + 1; j < n; j++) {
            (*comparacoes)++;
            if (vet[j].prioridade < vet[idxMin].prioridade) {
                idxMin = j;
            }
        }
        if (idxMin != i) {
            Componente tmp = vet[i];
            vet[i] = vet[idxMin];
            vet[idxMin] = tmp;
        }
    }

    clock_t fim = clock();
    return (double)(fim - ini) / CLOCKS_PER_SEC;
}

// =======================
// Busca bin√°ria por nome
// Retorna √≠ndice se encontrado, -1 caso n√£o encontrado.
// Tamb√©m conta compara√ß√µes atrav√©s de ponteiro comparacoes.
int buscaBinariaPorNome(Componente vet[], int n, const char chave[], long *comparacoes) {
    int inicio = 0, fim = n - 1;
    *comparacoes = 0;

    while (inicio <= fim) {
        int meio = (inicio + fim) / 2;
        (*comparacoes)++;
        int cmp = strcmp(vet[meio].nome, chave);
        if (cmp == 0) {
            return meio;
        } else if (cmp < 0) {
            inicio = meio + 1;
        } else {
            fim = meio - 1;
        }
    }
    return -1;
}

// =======================
// Entrada de componentes (at√© MAX_COMPONENTES)
// =======================
int cadastrarComponentes(Componente vet[]) {
    int n = 0;
    char buffer[128];

    printf("\nQuantos componentes deseja cadastrar? (1 a %d): ", MAX_COMPONENTES);
    if (fgets(buffer, sizeof(buffer), stdin) == NULL) return 0;
    int qtd = atoi(buffer);
    if (qtd < 1) qtd = 1;
    if (qtd > MAX_COMPONENTES) qtd = MAX_COMPONENTES;

    for (int i = 0; i < qtd; i++) {
        printf("\nComponente %d:\n", i + 1);
        printf("Nome: ");
        if (fgets(vet[i].nome, TAM_NOME, stdin) == NULL) vet[i].nome[0] = '\0';
        trim_newline(vet[i].nome);

        printf("Tipo: ");
        if (fgets(vet[i].tipo, TAM_TIPO, stdin) == NULL) vet[i].tipo[0] = '\0';
        trim_newline(vet[i].tipo);

        // prioridade (int)
        int prio = 0;
        while (1) {
            printf("Prioridade (1 a 10): ");
            if (fgets(buffer, sizeof(buffer), stdin) == NULL) { prio = 1; break; }
            prio = atoi(buffer);
            if (prio >= 1 && prio <= 10) break;
            printf("Valor inv√°lido. Insira entre 1 e 10.\n");
        }
        vet[i].prioridade = prio;
        n++;
    }
    return n;
}

// =======================
// Main: menu e fluxo
// =======================
int main() {
    Componente componentes[MAX_COMPONENTES];
    int n = 0;
    int opcao;

    printf("=== M√≥dulo de Prioriza√ß√£o e Montagem da Torre de Resgate ===\n");

    // cadastro inicial
    n = cadastrarComponentes(componentes);
    mostrarComponentes(componentes, n);

    // vari√°veis para medi√ß√µes
    long comparacoes;
    double tempo;
    char chave[TAM_NOME];

    do {
        printf("\n--- MENU ---\n");
        printf("1 - Ordenar por NOME (Bubble) e Buscar bin√°ria por nome\n");
        printf("2 - Ordenar por TIPO (Insertion)\n");
        printf("3 - Ordenar por PRIORIDADE (Selection)\n");
        printf("4 - Mostrar componentes\n");
        printf("5 - Re-cadastrar (limpar e cadastrar novos)\n");
        printf("0 - Sair\n");
        printf("Escolha uma op√ß√£o: ");

        if (scanf("%d", &opcao) != 1) {
            // limpar stdin e continuar
            int c;
            while ((c = getchar()) != EOF && c != '\n');
            opcao = -1;
        } else {
            int c;
            while ((c = getchar()) != EOF && c != '\n'); // limpar buffer
        }

        switch (opcao) {
            case 1:
                // bubble por nome
                tempo = bubbleSortNome(componentes, n, &comparacoes);
                printf("\n>> Resultado: Bubble sort por NOME conclu√≠do.\n");
                printf("Compara√ß√µes realizadas: %ld\n", comparacoes);
                printf("Tempo gasto: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, n);

                // se quiser buscar a "chave"
                printf("\nDigite o NOME do componente-chave para busca bin√°ria (ou apenas ENTER para pular): ");
                if (fgets(chave, sizeof(chave), stdin) != NULL) {
                    trim_newline(chave);
                    if (strlen(chave) > 0) {
                        long compBin;
                        int idx = buscaBinariaPorNome(componentes, n, chave, &compBin);
                        if (idx >= 0) {
                            printf("üîì Componente-chave encontrado no √≠ndice %d:\n", idx);
                            printf("Nome: %s | Tipo: %s | Prioridade: %d\n",
                                   componentes[idx].nome, componentes[idx].tipo, componentes[idx].prioridade);
                        } else {
                            printf("‚ö†Ô∏è Componente-chave N√ÉO encontrado.\n");
                        }
                        printf("Compara√ß√µes (busca bin√°ria): %ld\n", compBin);
                    } else {
                        printf("Busca bin√°ria ignorada.\n");
                    }
                }
                break;

            case 2:
                // insertion por tipo
                tempo = insertionSortTipo(componentes, n, &comparacoes);
                printf("\n>> Resultado: Insertion sort por TIPO conclu√≠do.\n");
                printf("Compara√ß√µes realizadas: %ld\n", comparacoes);
                printf("Tempo gasto: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, n);
                break;

            case 3:
                // selection por prioridade
                tempo = selectionSortPrioridade(componentes, n, &comparacoes);
                printf("\n>> Resultado: Selection sort por PRIORIDADE conclu√≠do.\n");
                printf("Compara√ß√µes realizadas: %ld\n", comparacoes);
                printf("Tempo gasto: %.6f segundos\n", tempo);
                mostrarComponentes(componentes, n);
                break;

            case 4:
                mostrarComponentes(componentes, n);
                break;

            case 5:
                // recadastrar
                n = cadastrarComponentes(componentes);
                mostrarComponentes(componentes, n);
                break;

            case 0:
                printf("\nSaindo... boa sorte na fuga!\n");
                break;

            default:
                printf("Op√ß√£o inv√°lida. Tente novamente.\n");
                break;
        }

    } while (opcao != 0);

    return 0;
}
